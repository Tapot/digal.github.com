---
layout: post
title: "Squeryl"
date: 2011-09-25 21:46
comments: true
categories: squeryl
published: false
---

Каждый, кто когда-либо пытался использовать "традиционные" ORM типа Hibernate знает, что тот уровень абстракций, которые они предоставляют, хорошо работает только для простых запросов. Как только возникает потребность сделать выборку более или менее сложную либо по условию, либо по выдаваемому набору данных, разработчику приходится начинать сражение с высокоуровневым языком запросов (типа HQL), использование которого несёт в себе сразу ряд проблем. Во-первых, это ещё один язык запросов, похожий на SQL, но им не являющийся. Во-вторых, сразу теряются остатки type safety. В четвёртых, при любом изменении схемы нужно проверять и править ручками **все** строки запросов в коде. Добавьте сюда сложную внутреннюю логику ORM, когда программисту довольно сложно сходу понять, когда и какие именно запросы будут сделаны к базе.

Squeryl - это scala-библиотека, призванная решить хотя бы часть этих проблем, и решает она их с широкомасштабным применением средств языка.

## Инициализация

Итак, для начала нужно инициализировать драйвер и реализовать фабрику сессий. Не надо пугаться названия, это всего лишь функция, возвращающая экземпляр класса Session:

``` scala

    import org.squeryl.SessionFactory
     
      Class.forName("org.postgresql.Driver");
     
      SessionFactory.concreteFactory = Some(()=>
        Session.create(
          java.sql.DriverManager.getConnection("..."),
          new PostgreSqlAdapter))

``` 

Это довольно простой пример, скорее всего в реальном проекте будет уместнее использовать Connection Pool, типа [DBCP](http://commons.apache.org/dbcp/) или [BoneCP](http://jolbox.com/). 

## Схема.

Следующим шагом, как и в других ORM, будет объявление схемы. Есть два режима работы со squeryl: использование примитивных типов (PrimitiveTypeMode) и типов-врапперов (CustomTypeMode), которые могут, например, включать в себя валидацию.

Классы схемы могут быть любыми скаловскими классами, поля, объявленные в конструкторе будут столбцами. Поля могут быть как mutable, так и immutable. Я предпочитаю для большей ясности использовать второй вариант в сочетании с case-классами и при необходимости просто вызывать метод copy. Однако, стоит заметить что этот способ имеет свои недостатки (например, не будет работать "из коробки" optimistic concurrency control, поскольку поле с версией не будет копироваться при вызове copy).

``` scala

    import org.squeryl.PrimitiveTypeMode._
    import org.squery.Schema
    import org.squeryl.annotations.Column

    case class User(
      id:     Long = 0,
      @Column(length = 256)
      email:  String,
      name:   String
    ) extends KeyedEntity[Long]

```

Трейт KeyedEntity просто говорит Squeryl что id является первичным ключом, позволяя, например, упростить поиск записи по id до вызова единственного метода `lookup(id)` над таблицей.

Таблицы и связи между ними описываются в классе, отнаследованным от Schema, в большинстве случаев можно сделать его singleton'ом:

``` scala

    object MySchema extends Schema {
      val users = table[User]

      on(users) { u => declare(
          u.id    is (autoIncremented),
          u.email is (unique)
        )
      }
    }

```

Итак, мы объявили схему и можем приступить с тому, ради чего, собственно всё и затевалось. Для начала создадим несколько пользователей:

``` scala

    import MySchema._
    
    val vasya = users.insert(new User("vasya@example.com", "Vasya Poupkine"))
    val masha = users.insert(new User("masha@example.com", "Masha Petrova"))
       
```


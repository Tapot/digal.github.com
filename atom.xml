<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Лошоть и байты</title>
  <link href="http://digal.github.com/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2011-08-24T12:31:03+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name>Yuri Buyanov</name>
    
  </author>

  
  <entry>
    <title>Scala IRL. Часть 1: конфиги.</title>
    <link href="http://digal.github.com/blog/2011/08/23/scala-irl-1-configs/"/>
    <updated>2011-08-23T22:40:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/23/scala-irl-1-configs</id>
    <content type="html">&lt;p&gt;Для Scala, как для языка довольно молодого, пока ещё нет (а может уже и не будет) единого стандарта для такой обыденной вещи как конфиг-файлы. Вариантов не так уж много и в этом посте я хочу сделать небольшой обзор тех, которые мне так или иначе довелось использовать.&lt;/p&gt;

&lt;h3&gt;.properties&lt;/h3&gt;

&lt;p&gt;Текстовые и XML файлы, хранящие пары &quot;ключ-значение&quot;. Вполне подходят для конфигурирования большинства проектов, а в стандартной библиотеке JRE, есть средства для работы с ними. Что касается поддержки со стороны Scala, в пакете &lt;code&gt;scala.collection&lt;/code&gt; есть объекты &lt;code&gt;JavaConverters&lt;/code&gt; и &lt;code&gt;JavaConversions&lt;/code&gt;, предоставляющие implicit методы для конвертации объектов класса &lt;code&gt;Properties&lt;/code&gt; в &lt;code&gt;mutable.Map[String, String]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Эти файлы часто используются не столько для хранения конфигов, сколько для локализации. Тут нельзя промолчать об одной их особенности, о которой, наверное, знает каждый Java-программист, но которая всегда меня изумляла: в платформе, где Unicode является основной кодировкой для работы со строками, для хранения локализованных строк предлагается формат, &lt;strong&gt;не поддерживаюший unicode&lt;/strong&gt;. Файлы предлагается сначала писать в unicode, а потом конвертировать в странный и уродливый формат утилитой native2ascii. Ну не отвратительно ли?&lt;/p&gt;

&lt;p&gt;Эти же файлы использует фреймворк Lift (с расширением .props), добавляя к ним &lt;a href=&quot;http://www.assembla.com/wiki/show/liftweb/Run_Modes&quot;&gt;замысловатый механизм&lt;/a&gt; выбора нужного файла в зависимости от режима работы (run mode) и окружения.&lt;/p&gt;

&lt;h3&gt;XML и JSON&lt;/h3&gt;

&lt;p&gt;Здесь всё понятно: стандартных библиотек целая куча, и старые явовские, и специально сделанные для Scala с вкусностями типа XPath-подобных DSL. Такие конфиги имеют привычку разрастаться до неприличных размеров, а JSON ещё и не умеет удобно работать с длинными и многострочными значениями и не имеет констукции для комментариев. Впрочем, можно просто использовать для этой цели обычные поля, которые при чтении конфига будут игнорироваться.&lt;/p&gt;

&lt;h3&gt;configgy&lt;/h3&gt;

&lt;p&gt;configgy - замечательная Scala-библиотека, выполняющая сразу две задачи: работа с конфиг-файлами и удобный логгинг. Эти задачи практически никак не связаны между собой (за исключением того, что логгинг тоже надо конфигурировать), но это именно те две задачи, которые требуется решать в практически любом проекте больше сотни строк.&lt;/p&gt;

&lt;p&gt;Configgy поддерживает несколько форматов для конфигов, как линейный, так и со вложенными блоками, типа такого:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# JDBC parameters
jdbc {
    driver = &quot;com.mysql.jdbc.Driver&quot;
    uri = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF8&quot;
    limit = 5000 # Batch size for selects
}

#logging parameters, see configgy readme for details
log {
    filename = &quot;debug.log&quot;
    level = &quot;debug&quot;
    utc = false
    console = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Логгинг автоматически подхватывает параметры из секции log при чтении конфига, что очень удобно - вся обычная рутина с конфигурированием сводится практически к одной строчке.&lt;/p&gt;

&lt;h3&gt;Ostrich&lt;/h3&gt;

&lt;p&gt;Когда мы собрались прицепить configgy к одному из очередных наших проектов, то обнаружили (на &lt;a href=&quot;https://github.com/robey/configgy&quot;&gt;страничке&lt;/a&gt; проекта на github), что проект теперь deprecated (хотя и будет пока поддерживаться в каком-то виде) и вместо него предлагается использовать Scala-библиотеки от twitter. Для логгинга - util-logging из набора &lt;a href=&quot;https://github.com/twitter/util&quot;&gt;Util&lt;/a&gt;, который помимо лог-файлов поддерживает &lt;a href=&quot;https://github.com/facebook/scribe&quot;&gt;Scribe&lt;/a&gt; и Syslog, для конфигурирования - &lt;a href=&quot;https://github.com/twitter/ostrich&quot;&gt;ostrich&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ostrich - это довольно развесистая библиотека, предназначенная для&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;конфигурирования&lt;/li&gt;
&lt;li&gt;сбора статистики&lt;/li&gt;
&lt;li&gt;запуска/остановки приложения и его сервисов&lt;/li&gt;
&lt;li&gt;предоставления админского интерфейса через HTTP или просто сокет&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Главная особенность конфиг-файлов ostrich - они являются обычными Scala-классами, со всемы вытекающими: они типизированы и могут наследоваться от абстрактного класса или трейта. В тех местах, где конфигурация используется, отпадает необходимость извлечения значений из конфига, проверки на то что они присутствуют, предоставления дефолтных значений и приведения к нужному типу. Обратной стороной медали можно было бы назвать необходимость компиляции конфига в рантайме, но поскольку делать это нужно не так уж часто (обычно при старте приложения), то ради красивых type-safe конфигов можно и потерпеть.&lt;/p&gt;

&lt;p&gt;Также, ostrich предоставляет готовую заготовку ServerConfig, включающую в себя настройку логгинга и поднятие http/socket интерфейса при загрузке.&lt;/p&gt;

&lt;p&gt;Несмотря на фичастость, мне кажется что автор configgy совершенно зря остановил развитие библиотеки: она очень проста в использовании и идеально подходит для большого диапазона проектов. Ostrich же относится к совершенно другой категории и для многих задач его навороченность выглядит излишней. Кроме того, в его использовании есть несколько подводных камней, о которых я постараюсь рассказать поподробнее в следующий раз.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Очередная классификация программистов</title>
    <link href="http://digal.github.com/blog/2011/08/20/types-of-programmers/"/>
    <updated>2011-08-20T11:31:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/20/types-of-programmers</id>
    <content type="html">&lt;p&gt;Утром наткнулся в zite на замечательную статью: &quot;&lt;a href=&quot;http://techiferous.com/2011/08/are-you-a-good-programmer/&quot;&gt;Are You a Good Programmer?&lt;/a&gt;&quot;, в которой приведена интересная классификация &lt;em&gt;хороших&lt;/em&gt; программистов. Несмотря на всю относительность таких классификаций, очень занимательно примерять это всё на себя.&lt;/p&gt;

&lt;p&gt;Мне трудно судить, являюсь ли я на данный момент действительно хорошим программистом (и каким критериям, собственно, надо для этого соответствовать?), но определённо могу сказать что последний год развиваюсь в сторону первого типа (Philosopher). Этому явно способствует и спользование такого языка как scala, склоняющая к очень &quot;безопасному&quot; стилю программирования, и позволяющая хорошо управлять ограничениями в коде с помощью системы типов, при этом сохраняя красоту и лаконичность кода.&lt;/p&gt;

&lt;p&gt;Было бы интересно узнать, к какому типу вы себя относите? Понятно что типы могут сочетаться в разных пропорциях, и вполне возможно, что можно придумать ещё несколько.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Ура! Новый хоумпейж!</title>
    <link href="http://digal.github.com/blog/2011/08/15/"/>
    <updated>2011-08-15T11:19:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/</id>
    <content type="html">&lt;p&gt;Уф, я кажется таки настроил &lt;a href=&quot;http://octopress.org/&quot; title=&quot;Octopress: A blogging framework for hackers.&quot;&gt;octopress&lt;/a&gt; и наверное таки останусь здесь.
Несмотря на излишнюю красноглазость (девиз октопресса говорит сам за себя) эта платформа ближе всего к идеалу блогдвижка, как я его представляю.
Как дойдут руки, я попробую доконфигурить это до юзабельного состояния (&quot;ха-ха!&quot; - как бы говорит линуксоедный опыт) и начать уже писать посты,
благо исчезает последняя отмазка этого не делать - отсутствие нормального блога.&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;До этого я пробовал ЖЖ, blogspot, tumblr, posterous и бложеки на корпоративном сайте. Прижился только &lt;a href=&quot;http://twitter.com/digal&quot;&gt;твитор&lt;/a&gt;,
но его 140 символов не всегда хватает чтобы выпендриться умом.&lt;/p&gt;

&lt;p&gt;Я пока не уверен в идеальном процентном соотношении красноглазия/лытдыбра (в смысле постов на профессиональные/личные темы), так что буду писать
как получится, а дальше отрегулирую по фидбекам.&lt;/p&gt;

&lt;p&gt;Алсо, если кто-то будет тоже настраивать octopress, то не наступайте на граблю, на которую я убил наверное час нервных рефрешей этой страницы:
если делать всё по официальному гайду, то скорее всего дефолтным бранчем в гитхаб-репозитории у вас окажется &quot;source&quot;, а не &quot;master&quot;, который
собственно и нужно публиковать. Переключить это можно в настройках репозитория.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Hello?</title>
    <link href="http://digal.github.com/blog/2011/08/15/hello/"/>
    <updated>2011-08-15T11:15:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/15/hello</id>
    <content type="html">&lt;p&gt;Привет? Рас-рас!&lt;/p&gt;
</content>
  </entry>
  
</feed>

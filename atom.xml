<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title>Лошоть и байты</title>
  <link href="http://digal.github.com/atom.xml" rel="self"/>
  <link href="http://digal.github.com/"/>
  <updated>2011-11-22T13:15:02+04:00</updated>
  <id>http://digal.github.com/</id>
  <author>
    <name>Yuri Buyanov</name>
    
  </author>

  
  <entry>
    <title>iOS-dev: первые впечатления. Язык.</title>
    <link href="http://digal.github.com/blog/2011/11/22/ios-impressions/"/>
    <updated>2011-11-22T10:22:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/11/22/ios-impressions</id>
    <content type="html">&lt;p&gt;Недели три назад мне пришлось основательно взяться за разработку под iOS и (куда же тут без него) Objective-C. Из всего опыта была только прочитанная летом наполовину &lt;a href=&quot;http://oreilly.com/catalog/9781449397296&quot;&gt;книжка&lt;/a&gt; по сабжу, пару раз открытый XCode, и попытка собрать &lt;a href=&quot;http://www.scummvm.org/&quot;&gt;ScummVM&lt;/a&gt; для iPad из сорцов. Надо сказать что идея овладеть obj-c появилась у меня в голове ещё больше года назад (с появлением iPad), а после переезда на мак этому не оставалось уже никаких препятствий.&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;Заранее извиняюсь у экспертов в iOS-деве за возможные ляпы: всё-таки, несколько недель это слишком мало чтобы досконально изучить все тонкости разработки под новую для себя платформу (но в самый раз чтобы зафиксировать впечатления, пока они не успели выветриться из головы). Если вы найдёте какую-то неточность или ошибку - пишите и я обязательно постараюсь её исправить.&lt;/p&gt;

&lt;h2&gt;Тёплые ламповости&lt;/h2&gt;

&lt;p&gt;Итак, первое что бросается в глаза тому, кто приходит писать под Cocoa (это, если кто не знает, UI-фреймворк в OSX/iOS) - непривычно выглядящий Objective-C. Многие ставят ему в вину необычный синтаксис для вызова методов (которые являются smalltalk-style посылкой сообщений). На самом деле, синтаксис любого языка это, конечно же дело вкуса, и, наверное, самая малая часть из того, к чему приходится привыкать при разработке под новую платформу.&lt;/p&gt;

&lt;p&gt;С другой стороны, привычка (выработанная в Scala) выстраивать вызовы методов в длинные цепочки приводит к совершенно нечитаемым кускам кода:&lt;/p&gt;

&lt;p&gt;``` objc&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;html&quot;] isDirectory:NO]]];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Единственный способ сделать это читаемым - вынести результаты вызовов методов в отдельные переменные. Но даже это окончательно не решит проблему: даже простой вызов метода с четыремя параметрами вполне может не влезть в одну строку, благодаря необходимости указывать имена аргументов и любви создателей библиотек к длинными именам. Последнее, кстати, частично вызвано отсутствием хоть какой-либо системы неймспейсов: приходится следить за уникальностью имён классов, добавляя к ним префиксы.&lt;/p&gt;

&lt;p&gt;Ешё одно наследие C, сильно раздражающее перебежчиков из других языков - необходимость создания отдельных заголовочных файлов (.h). Это сразу в два раза увеличивает количество сорцовых файлов в проекте, а любое более-менее серьёзное изменение требует правки сразу обоих файлов.&lt;/p&gt;

&lt;h2&gt;Нераскрытые возможности&lt;/h2&gt;

&lt;p&gt;Впрочем, это всё мелочи, с которыми можно смириться. Можно даже их любить, если вас греет ощущение использования тёплого лампового языка. От чего действительно становится немного грустно, так это (как ни странно) от его достоинств и клёвых фич. Здесь Objective-C немного напоминает JavaScript лет 5-10 назад, когда большинство программистов на нём просто до конца не понимали что им делать со всей этой динамичностью, прототипами и замыканиями.&lt;/p&gt;

&lt;p&gt;Итак, как я уже говорил, вызов метода в Objective-C является передачей сообщения от одного объекта другому. Это очень похоже на то, как это сделано в Ruby. Предвидя возмущение некоторых поклонников Erlang от того факта что передача сообщений происходит синхронно (а поэтому сообщения там &quot;ненастоящие&quot;), надо заметить что впервые эта концепция и терминология была предложена в Smalltalk (если не раньше), лет эдак за 15 до Erlang.&lt;/p&gt;

&lt;p&gt;Как и Ruby, Objective-C &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html&quot;&gt;умеет&lt;/a&gt; обрабатывать неизвестные сообщения (то есть те, для которых не написаны методы). Однако, в отличие от Ruby или Groovy, где возможности метапрограмминга используются на полную катушку, obj-c разработчики, похоже, рассматривают эту возможность скорее как метод расстановки костылей. Хотя лично мне кажется, что аналог &lt;a href=&quot;http://guides.rubyonrails.org/active_record_querying.html#dynamic-finders&quot;&gt;dynamic finders в activerecord&lt;/a&gt; был бы отличным дополнением к core data.&lt;/p&gt;

&lt;p&gt;Ещё одна относительно новая фича языка, блоки (&quot;form of closures&quot;, как говорит википедия), практически не используется в полную силу. Похоже, ни разработчики библиотек, ни прикладные ios-девелоперы просто не понимают, зачем им это нужно. Хотя, в отличие от предыдущего примера с dynamic finders, мне удалось найти несколько библиотек, пытающихся прикрутить ФП к Objective-C. Самая развесистая - это, пожалуй, &lt;a href=&quot;https://github.com/mogeneration/functionalkit/&quot;&gt;FunctionalKit&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Остальное&lt;/h2&gt;

&lt;p&gt;С остальными вещами всё более-менее понятно: это протоколы (читай интерфейсы), категории (иногда их ошибочно &lt;a href=&quot;http://stackoverflow.com/questions/1244748/objective-c-category-compared-to-mixins&quot;&gt;считают&lt;/a&gt; миксинами, хотя они скорее являются формой манки-патчинга) и полуавтоматический менеджмент указателей. Последнее, наверное, пугает java- и других &quot;высокоуровневых&quot; девелоперов больше всего, однако на практике здесь всё просто. Хотя не к месту всунутый autorelease может доставить немало приятных минут в дебаггере, а устроить себе утечку памяти - вообще как нефиг делать. Всё это хорошо описано и давно используется в повседневной разработке.&lt;/p&gt;

&lt;p&gt;Это пожалуй всё, что я хотел сказать об Objective-C. В следующем посте (или постах) я постараюсь рассказать об инструментах разработки и экосистеме этой платформы в целом.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Squeryl: Двигаемся дальше</title>
    <link href="http://digal.github.com/blog/2011/10/03/squeryl-advanced/"/>
    <updated>2011-10-03T22:38:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/10/03/squeryl-advanced</id>
    <content type="html">&lt;p&gt;Итак, продолжаем наше знакомство со &lt;a href=&quot;http://squeryl.org/&quot;&gt;Sueryl&lt;/a&gt; (начало &lt;a href=&quot;https://digal.github.com/blog/2011/09/25/squeryl/&quot;&gt;тут&lt;/a&gt;). Для начала, вернёмся к селектам и рассмотрим одну из интереснейших фич Squeryl.&lt;/p&gt;

&lt;!--more--&gt;


&lt;h2&gt;Составные селекты&lt;/h2&gt;

&lt;p&gt;Итак, &lt;code&gt;select&lt;/code&gt; в любой его форме возвращает нам объект класса &lt;code&gt;Query&lt;/code&gt; (кроме &lt;code&gt;lookup&lt;/code&gt;, возвращающего &lt;code&gt;Option&lt;/code&gt;). Этот класс играет сразу две роли. Во-первых, из него можно просто получить результат выборки, используя его в качестве обычной коллекции (он расширяет трейт &lt;code&gt;Iterable&lt;/code&gt;). А во-вторых (и это самое интересное) - его можно использовать для построения более сложных запросов к базе. Например, подсунуть его в &lt;code&gt;from&lt;/code&gt; вместо таблицы:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val rated = 
  users.where( _.rating.~ &amp;gt;= 0)

val vasyasRated =
  from(rated) ( u =&amp;gt;
    select(u)
    where(u.name like &quot;%Vasya%&quot;) 
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;В этом примере мы использовали запрос &lt;code&gt;rated&lt;/code&gt; для построения второго запроса. (Кстати, в первом посте я не упомянул о маленьком но полезном кусочке синтаксического сахара: упрощённом синтаксисе для &lt;code&gt;select&lt;/code&gt;. Пример его использования можно увидеть в первом запросе.)&lt;/p&gt;

&lt;p&gt;Можно и использовать результат одного селекта внутри блока &lt;code&gt;where&lt;/code&gt; второго:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val vasyasRated =
  from(users) ( u =&amp;gt;
    select(u)
    where(u.id in 
      from(rated) (r =&amp;gt; select(r.id))
    ) 
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Ну и, в конце концов можно добавить к &lt;code&gt;Query&lt;/code&gt; разные полезные модификаторы. Для постраничной выборки:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(users) ( u =&amp;gt; ... ).page(offset, pageLength)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;для выборки уникальных строк:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(users) ( u =&amp;gt; ... ).distinct
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;или для выборки элементов для обновления (директива FOR UPDATE в SQL):&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(users) ( u =&amp;gt; ... ).forUpdate    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Всё это, при желании, даёт возможность писать код максимально соответствующий принципу DRY (&quot;don't repeat yourself&quot;, если вдруг кто не знает).&lt;/p&gt;

&lt;h2&gt;Агрегация&lt;/h2&gt;

&lt;p&gt;Агрегация - это, наверное, единственная часть DSL, где Squeryl отходит от SQL: вместо использования &lt;code&gt;select&lt;/code&gt;, агрегирующие функции описываются в конструкии &lt;code&gt;compute&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val ratingDistribution =
  from(users) ( u =&amp;gt;
    groupBy(u.rating)
    compute(count(u.id))
  )

ratingDistribution foreach { r=&amp;gt;
  println(&quot;%s: %s&quot; format (r.key, r.measures))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Результатом такого кода становится объект вида &lt;code&gt;Query[ GroupWithMeasures[Int, Int] ]&lt;/code&gt;, который можно использовать явно, обращаясь к полям &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;measures&lt;/code&gt;, либо приведя его к коллекции типа &lt;code&gt;Map&lt;/code&gt;, вызовом метода &lt;code&gt;toMap&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Join&lt;/h2&gt;

&lt;p&gt;С джойнами тоже всё довольно просто. Обычный INNER JOIN так же как и в SQL можно делать неявно, просто сделав &lt;code&gt;select&lt;/code&gt; из двух таблиц и добавив условие в &lt;code&gt;where&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(users, posts) ( (u,p) =&amp;gt;
  select(u.name, p)
  where(u.id === p.userId)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Можно использовать OUTER JOIN и всё, к чему вы привыкли в SQL:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from(users, avatars.leftOuter) ( (u,a) =&amp;gt;
  select(u, a.url)
  on(u.id === a.map(_.userId))
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;В случае использования внешнего джойна, для юзера не всегда находится соответствующая аватарка, поэтому &lt;code&gt;a&lt;/code&gt; в этом примере имеет тип Option.&lt;/p&gt;

&lt;h2&gt;Relations&lt;/h2&gt;

&lt;p&gt;Зачастую, одна из самых сложных для понимания и использования вещей в обычных ORM - отношения one-to-many и many-to-many между таблицами. Именно там кроется большая часть граблей, на которые наступают неопытные разработчики.&lt;/p&gt;

&lt;p&gt;Подобно scala collections, имеющим две ипостаси: immutable и mutable, отношения в Squeryl делятся на &lt;strong&gt;stateless&lt;/strong&gt;, являющиеся, по-сути, заранее подготовленными запросами (&lt;code&gt;Query&lt;/code&gt;) и &lt;strong&gt;stateful&lt;/strong&gt; хранящими все связанные записи в памяти в виде коллекции (&lt;code&gt;Iterable&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Для использования любого из этих вариантов, мы должны описать связь между таблицами в нашей схеме.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object MySchema extends Schema {
  val users = table[User]
  val posts = table[Post]

  val userPosts = 
    oneToManyRelation(users, posts) via ( (u,p) =&amp;gt;
      u.id === p.userId
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;В этом посте я возьму для примера отношения one-to-many. DSL для описания many-to-many не сильно от него отличается и хорошо описан в &lt;a href=&quot;http://squeryl.org/relations.html&quot;&gt;документации&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case class User (....) extends KeyedEntity[Long] {
  //OneToMany[Post] &amp;lt; Query
  lazy val posts = MySchema.userPosts.left(this)
}

case class User (....) extends KeyedEntity[Long] {
  //ManyToOne[User] &amp;lt; Query
  lazy val user = MySchema.userPosts.right(this)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Теперь мы можем использовать наш релейшен так же как и обычный &lt;code&gt;select&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (p &amp;lt;- user.posts) 
  println(p.title)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Кроме этого, stateless relations имеют несколько полезных методов для манипулирования дочерними элементами:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;assign&lt;/code&gt; - привязывает дочерний элемент родительскому, выставляя значение foreign key (имеет смысл только если foreign key - изменяемое поле)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;associate&lt;/code&gt; - делает &lt;code&gt;assign&lt;/code&gt; + сохраняет эту связь в базе&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deleteAll&lt;/code&gt; - удаляет все дочерние элементы из базы&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Объявление stateful relation не сильно сложнее:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case class User (....) extends KeyedEntity[Long] {

  //StatefulOneToMany[Post] &amp;lt; Iterable[Post]
  lazy val posts = MySchema.userPosts.leftStateful(this)

}

case User (....) extends KeyedEntity[Long] {

  //StetefulManyToOne[User]
  lazy val user = MySchema.userPosts.rightStateful(this)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;По сути, stateful relations являются простыми врапперами вокруг stateless, добавляющими кеширование данных в памяти, что избавляет Squeryl от необходимость делать запрос к базе при каждом обращении к коллекции.&lt;/p&gt;

&lt;h2&gt;Недостатки&lt;/h2&gt;

&lt;p&gt;Трудно сказать, является это недостатком Squeryl или моим, однако не все механизмы работы этого DSL мне до конца ясны. В частности, я так и не понял, с применением какой магии обычные поля классов модели конвертируются в метаданные столбцов в базе. Ведь это делается не только при создании таблицы, но и во время компиляции (или уже в рантайме) замыканий внутри запросов (например, &lt;code&gt;where&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Один раз, когда мне надо было вынести один из часто используемых паттернов для апдейтов в отдельный метод, магия DSL отказалась работать и мне пришлось расковырять библиотеку и извлечь на свет страннейший артефакт чёрной магии под названием (осторожно): &lt;code&gt;createEqualityExpressionWithLastAccessedFieldReferenceAndConstant&lt;/code&gt;. Вам страшно? Мне тоже. Хорошо что такой случай был пока один, и у вас есть все шансы не напороться даже на него (уж больно он специфический).&lt;/p&gt;

&lt;p&gt;А вот с казалось бы элементарными, но не всегда работающими implicit conversions, являющимися неотъемлемой частью любого скаловского DSL, дело обстоит хуже. Приведу один только пример. В этом кусочке условия в &lt;code&gt;where&lt;/code&gt; я пытаюсь использовать ещё одну замечательную фичу - динамический запрос (то есть запрос, части которого включаются по условию, обычно при заполнении &lt;code&gt;Option&lt;/code&gt;, подробнее &lt;a href=&quot;http://squeryl.org/dynamic-queries.html&quot;&gt;тут&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;where ( u.flag === boolOpt.? ) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Очевидно, здесь DSL вступает в конфликт с синтаксическим сахаром для булевских условий (поскольку для строковых полей всё работает). Перепробовав несколько вариантов, я пришёл к вот такому вот монструозному решению:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;not(not(u.flag)).inhibitWhen(boolOpt != Some(true))  
and 
not(u.flag).inhibitWhen(boolOpt != Some(false))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Обратите внимание на изящный двойной &lt;code&gt;not&lt;/code&gt;, который пришлось использовать в качестве подсказки компилятору. Судя по всему, я оказался не единственным, кто столкнулся с этой проблемой: на StackOveflow мне &lt;a href=&quot;http://stackoverflow.com/questions/7607449/booleans-in-squeryl-dynamic-queries/7640585#7640585&quot;&gt;сообщили&lt;/a&gt; что в следующей версии этот сахар будет выключен и посоветовали более изящное решение с применением уже знакомого нам оператора &lt;code&gt;~&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;where ( u.flag === boolOpt.~.? )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Несмотря на некоторые недостатки, умолчать о которых было бы просто нечестно, Squeryl - замечательная библиотека, позволяющая решить кучу типичных проблем при использовании реляционных БД, не увеличивая сложность и размер кода. Лично я буду использовать её и дальше, что и вам советую делать.&lt;/p&gt;

&lt;p&gt;Эти два поста, посвящённые squeryl были в некотором роде заготовкой для выступления на нашем Scala-евенте (хотя это ещё вопрос, что вышло полуфабрикатом, а что полноценным туториалом). Видео моего (и не только) выступления можно найти в небольшом &lt;a href=&quot;http://habrahabr.ru/company/e-Legion/blog/130545/#comments&quot;&gt;отчёте с него&lt;/a&gt;, а слайды у меня на &lt;a href=&quot;http://dl.dropbox.com/u/12823109/squeryl.pdf&quot;&gt;дропбоксе&lt;/a&gt; (кавайные белочки инсайде). Удачи и до встреч.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Squeryl: основы</title>
    <link href="http://digal.github.com/blog/2011/09/25/squeryl/"/>
    <updated>2011-09-25T21:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/25/squeryl</id>
    <content type="html">&lt;p&gt;Этим и следующим постом (который, надеюсь, будет вот совсем скоро) я хочу познакомить вас с замечательной ORM-библиотекой для scala, которую сейчас использую в одном из рабочих проектов. Не надо пугаться аббревиатуры ORM: возожности маппинга к объектам здесь принципиально реализованы на совсем базовом уровне, а вот симпатичный DSL для запросов стоит того, чтобы на него взглянуть.&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;Каждый, кто когда-либо пытался использовать &quot;традиционные&quot; ORM типа Hibernate знает, что тот уровень абстракций, которые они предоставляют, хорошо работает только для простых запросов. Как только возникает потребность сделать выборку более или менее сложную либо по условию, либо по выдаваемому набору данных, разработчику приходится начинать сражение с высокоуровневым языком запросов (типа HQL), использование которого несёт в себе сразу ряд проблем. Во-первых, это ещё один язык запросов, похожий на SQL, но им не являющийся. Во-вторых, сразу теряются остатки type safety. В-третьих, при любом изменении схемы нужно проверять и править ручками &lt;strong&gt;все&lt;/strong&gt; строки запросов в коде. Добавьте сюда сложную внутреннюю логику ORM, когда программисту довольно сложно сходу понять, когда и какие именно запросы будут сделаны к базе и частенько страдающую производительность.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://squeryl.org/&quot;&gt;Squeryl&lt;/a&gt; - это scala-библиотека, призванная решить хотя бы часть этих проблем, и делает она это с широкомасштабным применением средств языка, а именно заточенностью под DSL и строгой типизацией всего что только можно. Таким образом, запросы имеют структуру, похожую на обычный SQL, являясь при этом scala-кодом. Scala-код, в отличие от SQL-запросов, тщательно проверяется компилятором, который сделает вам ататат, как только вы попытаетесь вписать строку в столбец типа Int или хотя бы сделать сравнение столбца типа Date с булевским значением.&lt;/p&gt;

&lt;h2&gt;Инициализация&lt;/h2&gt;

&lt;p&gt;Итак, для начала нужно инициализировать драйвер и реализовать фабрику сессий. Не надо пугаться названия, это всего лишь функция, возвращающая экземпляр класса Session:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.squeryl.SessionFactory

  Class.forName(&quot;org.h2.Driver&quot;);

  SessionFactory.concreteFactory = Some { ()=&amp;gt;
    Session.create(
      java.sql.DriverManager.getConnection(&quot;jdbc:h2:mem:&quot;),
      new H2Adapter
    )
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Это довольно простая реализация, в реальном проекте скорее всего будет уместнее использовать connection pool, типа &lt;a href=&quot;http://commons.apache.org/dbcp/&quot;&gt;DBCP&lt;/a&gt; или &lt;a href=&quot;http://jolbox.com/&quot;&gt;BoneCP&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Транзакции&lt;/h2&gt;

&lt;p&gt;С транзакциями всё просто: транзакция осуществляется с помощью двух методов &lt;code&gt;transaction&lt;/code&gt; и &lt;code&gt;inTransaction&lt;/code&gt;, которые, принимая на вход функцию, оборачивают её выполнение в транзакцию.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.squeryl.PrimitiveTypeMode._

transaction {

  //операции с данными ...

} //коммит транзакции
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Их отличие состоит в том, что &lt;code&gt;transaction&lt;/code&gt; всегда открывает новую транзакцию перед началом выполнения блока и коммитит после завершения, a &lt;code&gt;inTransaction&lt;/code&gt; делает это только в том случае, если не находится внутри другой транзакции.&lt;/p&gt;

&lt;h2&gt;Схема.&lt;/h2&gt;

&lt;p&gt;Следующим шагом, как и в других ORM, будет объявление схемы. Есть два режима работы со squeryl: использование примитивных типов (PrimitiveTypeMode) и типов-врапперов (CustomTypeMode), которые могут, например, включать в себя валидацию. Собственно для работы с DSL, необходим импорт членов одного из этих объектов (как это сделано в первой строчке предыдущего листинга).&lt;/p&gt;

&lt;p&gt;Классы схемы могут быть любыми скаловскими классами, поля, объявленные в конструкторе будут столбцами. Поля могут быть как mutable, так и immutable. Я предпочитаю для большей ясности использовать второй вариант в сочетании с case-классами и при необходимости просто вызывать метод copy. Однако, стоит заметить что этот способ имеет свои недостатки (например, не будет работать &quot;из коробки&quot; optimistic concurrency control, поскольку поле с версией не будет копироваться при вызове copy).&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;case class User(
  id:     Long = 0,
  @Column(length = 256)
  email:  String,
  name:   String,
  rating: Int = 0,
) extends KeyedEntity[Long]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Трейт KeyedEntity просто говорит Squeryl что id является первичным ключом, позволяя, например, упростить поиск записи по id до вызова единственного метода &lt;code&gt;lookup(id)&lt;/code&gt; над таблицей.&lt;/p&gt;

&lt;p&gt;Таблицы и связи между ними описываются в классе, отнаследованным от Schema, в большинстве случаев можно сделать его синглтоном:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object MySchema extends Schema {
  val users = table[User]

  on(users) { u =&amp;gt; declare(
      u.id    is (autoIncremented),
      u.email is (unique)
    )
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Наличие схемы, как в любом приличном ORM избавляет необходимости писать тонны SQL CREATE ручками. Для создания схемы в базе можно воспользоваться методом &lt;code&gt;create&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transaction {
  MySchema.create  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Аналогично, для импорта схемы в виде SQL, есть метод &lt;code&gt;printDdl&lt;/code&gt;, а для очистки базы - &lt;code&gt;drop&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;Insert&lt;/h2&gt;

&lt;p&gt;Итак, мы объявили схему и можем приступить к тому, ради чего, собственно, всё и затевалось. Для начала создадим несколько пользователей:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import MySchema._

val vasya = users.insert(new User(&quot;vasya@example.com&quot;, &quot;Vasya Poupkine&quot;))
val masha = users.insert(new User(&quot;masha@example.com&quot;, &quot;Masha Petrova&quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Select&lt;/h2&gt;

&lt;p&gt;Select в squeryl является практически двойником оного в SQL за исключением того, написан на Scala со всеми вытекающими плюшками:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import MySchema._

val nullRated = 
  from(users) ( u =&amp;gt;
    select(u)
    where(u.rating === 0) //(1)
  )

val mails = 
  from(users) ( u =&amp;gt;
    select(u.email)
  )

val idsWithMails = 
  from(users) ( u =&amp;gt;
    select(u.id, u.email)
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Обратите внимание на тройное &lt;code&gt;===&lt;/code&gt; (1). В отличие от обычного двойного &lt;code&gt;==&lt;/code&gt;  - это не встроенный в scala оператор, а конструкция DSL Squeryl.
Трейт &lt;code&gt;KeyedEntity&lt;/code&gt; даёт нам возможность использовать упрощённый синтаксис для поиска записи по id:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val zeroUser: Option[User] = users.lookup(id)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Update&lt;/h2&gt;

&lt;p&gt;Операция обновления в squeryl поддерживает два вида синтаксиса: частичное и полное обновление. Полное обновление, как следует из названия, использует в качестве источника обновлённых данных объект целиком. Поскольку в нашем примере классы целиком иммутабельны, мы будем подсовывать в update объекты, созданные через метод copy.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val updatedVasya = vasya.copy(rating = vasya.rating + 1)
users.update(updatedVasya)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Полный update всегда обновляет только одну запись, поэтому ничего не возвращает.&lt;/p&gt;

&lt;p&gt;При частичном обновлении используется конструкция DSL, похожая на ту, которую мы использовали в select:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val updated = 
  update(users) ( u =&amp;gt;
    set(u.rating := u.rating.~ + 1) //(1)
    where(u.name like &quot;%Vasya%&quot;)    //(2)
  )

println(&quot;%s Vasyas rated&quot; format updated) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Как это принято в JDBC, update возвращает количество обновлённых записей.&lt;/p&gt;

&lt;p&gt;Опять обратим внимание (1) на использование DSL-оператора присваивания (&lt;code&gt;:=&lt;/code&gt;) вместо 'родного' &lt;code&gt;=&lt;/code&gt; и на, конструкцию &lt;code&gt;.~&lt;/code&gt;, применяющуюся в PrimitiveTypeMode для того, чтобы компилятор не путал оператор &lt;code&gt;+&lt;/code&gt; у скаловского Int с таким же оператором в DSL. Вместо конструкци &lt;code&gt;field.~ + value&lt;/code&gt; можно использовать &lt;code&gt;field plus value&lt;/code&gt;, кому как нравится. Кроме того, мы использовали (2) ещё один оператор сравнения - SQL LIKE.&lt;/p&gt;

&lt;h2&gt;Delete&lt;/h2&gt;

&lt;p&gt;Удаление выполняется аналогично: либо по id (для классов, с примешанным KeyedEntity) либо по условию.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;users.deleted(1)

val deleted = 
  users.deleteWhere( u =&amp;gt;
    u.rating.~ &amp;lt; 0
  )

println(&quot;%s users deleted&quot; format deleted)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Продолжение следует&lt;/h2&gt;

&lt;p&gt;В следующем посте я постараюсь рассмотреть &quot;продвинутые&quot; функции squeryl: джойны, связи 1-to-many и many-to-many, составные запросы, итд. И ещё постараюсь не забыть пройтись с критикой по тем местам библиотеки, которые ещё требуют полировки. Критика и отзывы, как обычно приветствуются. До встречи.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Fixtures</title>
    <link href="http://digal.github.com/blog/2011/09/07/fixtures/"/>
    <updated>2011-09-07T09:46:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/07/fixtures</id>
    <content type="html">&lt;p&gt;В предыдущем посте я рассказывал об исполняемых конфигах ostrich и не упомянул особых их достоинств, кроме type safety и удобства работы с настройками со стороны приложения. На прошлой неделе я наткнулся на ещё один хороший юзкейс для таких конфигов.&lt;/p&gt;

&lt;p&gt;Предположим, мы развёртываем наше приложение в разных окружениях (dev, test, prod), и в некоторых из них было бы здорово иметь в базе некоторые начальные данные для упрощения, например, процесса тестирования. Есть несколько достаточно тривиальных, но не очень удобных способов решения этой проблемы, особенно если загрузка этих начальных данных - часть автоматического развёртывания через CI-сервер. В скриптовых языках, где исполняемые файлы настроек - норма, такие данные (называемые fixtures) часто делаются частью конфига.&lt;/p&gt;

&lt;p&gt;С ostrich реализация такой штуки становится делом буквально нескольких строк кода:&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;Итак, для начала добавим соответствующее поле в наш базовый конфиг, он же конфиг по умолчанию. Мы воспользуемся тем, что scala - функциональный язык, а конфиг в свою очередь - это обычный scala-класс.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DBConfig {

  ...

  /** Нужно ли сбросить и пересоздать базу? */
  var doReset = false

  /** Код, который нужно исполнить, если doReset == true */
  var fixtures: (DB =&amp;gt; Unit) = {db =&amp;gt; ()}  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;По умолчанию, поле fixtures - это ничего не делающая функция. Теперь добавим в код, отвечающий за инициализацию базы, обработку новых полей:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class DB(val config: DBConfig) {

  Class.forName(config.driver)

  ...

  transaction {
    if (config.doReset) {
      //drop and create tables
      MySchema.drop
      MySchema.create

      //Run fixtures
      logger.info(&quot;Running fixtures&quot;)
      config.fixtures(this)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Ну и наконец выставим необходимое значение в поле fixtures в нужных конфигах&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//myserver-test.scala
new MyServerConfig {

  ...

  dbConfig.doReset = true
  dbConfig.fixtures = { db =&amp;gt;
    //create test user
    val usr = db.createUser(&quot;user@example.com&quot;, &quot;password&quot;, &quot;ru_RU&quot;)

    //set user roles
    db.assignRoleForUser(usr.id, Role.ADMIN)
    db.assignRoleForUser(usr.id, Role.STAFF)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Вот, собственно, и всё: никаких самописных форматов для начальных данных, никаких SQL-файлов, которые нужно чинить при каждом изменении схемы. Мы описываем данные самым естественным для нас способом - в виде высокоуровневого кода, работающего с базой и использующего все возможности нашего приложения (и выбранного persistence-фреймворка). Более того, принцип используемый здесь можно легко применить не только к работе с базой, но и к любым другим частям приложения. Нужен тестовый файл в хитром формате, с которым работает наше приложение? Cоздаём его используя соответствующий API и он будет всегда актуален, даже если формат ещё не устаканился и разрабатывается параллельно с приложением.&lt;/p&gt;

&lt;p&gt;В общем, с ostrich гибкость настройки приложения ограничена только фантазией разработчика. Я практически уверен, что это не последний пост, посвящённый этой библиотеке.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Пример хорошего UX</title>
    <link href="http://digal.github.com/blog/2011/09/05/no-newsletters/"/>
    <updated>2011-09-05T12:15:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/09/05/no-newsletters</id>
    <content type="html">&lt;p&gt;Регистрируясь на &lt;a href=&quot;http://coderwall.com/&quot;&gt;coderwall&lt;/a&gt; (по наводке &lt;a href=&quot;http://twitter.com/shaman_sir&quot;&gt;@shaman_sir&lt;/a&gt;) увидел замечательный пример той самой области UX, не относящейся ни к дизайну ни к юзабилити. Ничего супер-пупер-грандиозного, просто под полем для ввода электропочты в форме регистрации - небольшое примечание.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;No spam, always private. We respect the sanctity of your email and share your dislike for spam and unnecessarily frequent newsletters. If you're interested in future coderwall news, we suggest you follow us on twitter.&lt;/p&gt;&lt;/blockquote&gt;


&lt;p&gt;Не знаю как вам, а мне безумно приятно видеть сервис, уважающий моё личное информационное пространство и максимально ненавязчиво предлагающий просто подписаться на твиттер, если уж мне так хочется читать относящиеся к нему новости. По-моему, это гораздо лучше обычной галочки &quot;присылать/не присылать новости&quot;: в случае с твиттером заранее знаешь, что отписаться при желании можно будет в любой момент и одной кнопкой. Я уже не говорю о случаях, когда пользователю вообще не оставляют никакого выбора.&lt;/p&gt;

&lt;p&gt;В общем, я кажется нашёл главный секрет хорошего UX: &quot;Уважай своего пользователя&quot;. Просто ведь, правда?&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala IRL. Часть 2: Готовим Домашнего Страуса</title>
    <link href="http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich/"/>
    <updated>2011-08-29T22:28:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/29/scala-irl-2-ostrich</id>
    <content type="html">&lt;p&gt;В предыдущем посте я мельком упомянул библиотеку ostrich в качестве инструмента для загрузки конфигов, в этом же постараюсь сделать более подробный обзор. Итак, &lt;a href=&quot;github.com/twitter/ostrich&quot;&gt;ostrich&lt;/a&gt; - это внутренняя библиотека от разработчиков &quot;твиттера&quot;, используемая в его компонентах. Несмотря на фичастость и навороченность, местами довольно-таки заметен её стиль, как библиотеки написанной в первую очередь &quot;для себя&quot;.&lt;/p&gt;

&lt;p&gt;Оstrich выполняет следующие задачи:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;загрузка и парсинг typesafe-конфигов (проще, говоря, конфигов в виде scala-кода)&lt;/li&gt;
&lt;li&gt;сбор рантайм-статистики и разнообразных метрик&lt;/li&gt;
&lt;li&gt;управление сервисами внутри процесса (запуск/остановка)&lt;/li&gt;
&lt;li&gt;предоставление простенького, но расширяемого администраторского интерфейса через http/socket&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;В этом посте я опишу работу с конфигами, а остальные возможности попробую раскрыть в последующих постах.&lt;/p&gt;

&lt;h2&gt;Страус и конфиги&lt;/h2&gt;

&lt;p&gt;Итак, ostrich предлагает использовать в качестве конфигов не просто структурированные текстовые файлы (json/xml/properties), а scala-код. Такой подход требует компиляции конфига при загрузке, но имеет ряд серьёзных преимуществ:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;типизация. Отпадает необходимость проверять и приводить значения из конфиг-файла к нужным типам&lt;/li&gt;
&lt;li&gt;возможность писать произвольный код в конфигах, помимо простых значений. Например, использовать текущую дату в произвольном формате в имени лог-файла, или получить значения каких-то параметров из базы или стороннего сервиса. По сути, конфиг-файл становится тем, что называется extension point.&lt;/li&gt;
&lt;li&gt;становятся ненужными отдельные классы, инкапсулирующие конфигурацию различных компонентов программы, или, по крайней мере, упрощается их создание.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Для начала, нам нужно создать родительский класс для настроек. Чаще всего удобно сделать его же конфигом по умолчанию. Предположим, мы хотим сконфигурировать небольшое серверное приложение. Для этого ostrich предоставляет класс ServerConfig (являющийся наследником Config, предоставляющего базовые функции такие как компиляция, валидация и обязательные/необязательные поля).&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import com.twitter.ostrich.admin._
import com.twitter.ostrich.admin.config._
import com.twitter.logging.config._
import com.twitter.logging.Level


class MyServerConfig extends ServerConfig[MyServer] {

  //ServerConfig, в отличие от просто Config, должен определить 
  //метод Apply, для создания инстанса сервера
  def apply(runtime: RuntimeEnvironment) = {
    new MyServer(this)
  }

  var port = 1234
  var workersNum = 10
  var baseUrl = &quot;http://localhost:%s&quot; format port
  var dbConfig = new DBConfig
}

case class DBConfig(
  var driver = &quot;org.h2.Driver&quot;
  var uri = &quot;jdbc:h2:mem:&quot;
  var create = true
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Надо заметить, что мы используем в этом конфиге изменяемые переменные (&lt;code&gt;var&lt;/code&gt;). В Scala это зачастую является признаком недостаточно функционального (декларативного) стиля, однако в данном случае это позволит писать лаконичные конфиги, выставляя значение полей простым присваиванием. Кроме того, этот же стиль используется при объявлении уже имеющихся в ServerConfig значений.&lt;/p&gt;

&lt;p&gt;Итак, теперь наш конфиг для, например, тестового сервера, может выглядеть так:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new MyServerConfig {
  port = 80
  baseUrl = &quot;http://test.myserver.com&quot;

  dbConfig.uri = &quot;jdbc:h2:/tmp/test.db;AUTO_SERVER=TRUE&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Вполне лаконично, и ничуть не хуже .properties и уж тем более XML-файла. Можем сохранить его под именем &lt;code&gt;test.scala&lt;/code&gt;, тогда наш сервер мы сможем запускать как&lt;/p&gt;

&lt;p&gt;``` bash&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -jar my-server.jar -f ./test.scala
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Загрузка&lt;/h2&gt;

&lt;p&gt;Теперь, наш файл настроек надо загрузить и использовать по назначению. Делать это логичнее всего поближе к точке входа, например в &lt;code&gt;main&lt;/code&gt;. Путь к файлу можно передать с параметром &lt;code&gt;-f&lt;/code&gt; при запуске приложения, а если его нет, то ostrich попытается найти его сам. Определение местоположения конфиг-файла - это то самое место, где становится видно, что проект делался для себя: ostrich ищет его в довольно специфических местах, пытаясь сначала выяснить имя jar-файла. Поэтому, проще всего всегда передавать путь к конфигу через &lt;code&gt;-f&lt;/code&gt; плюс явно указать конфиг по умолчанию. Поскольку конфиг по умолчанию является обычным scala-классом, можно просто создать его инстанс в коде. Вот как выглядит загрузка и использование конфига у меня:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object MyServer {
  def main(args: Array[String]) {
    val runtime = RuntimeEnvironment(this, args)
    val server =
      if (runtime.configFile.exists) //если ostrich нашёл конфиг-файл 
        runtime.loadRuntimeConfig[Server]()
      else //default
        (new MyServerConfig)()(runtime)

    server.start()
  }
}

class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)

  def start() {
    //...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Обратите внимание на строчку &lt;code&gt;(new MyServerConfig)()(runtime)&lt;/code&gt;: сначала мы вызываем метод apply без параметров, а потом вызываем полученную функцию с параметром типа RuntimeEnvironment. При необходимости, этот способ можно расширить для загрузки различных конфигов по умолчанию, например в зависимости от &lt;code&gt;run.mode&lt;/code&gt; в lift.&lt;/p&gt;

&lt;p&gt;Я не использовал возможность ostrich объявлять поля как обязательные/опциональные, но промолчать о ней будет, наверное, неправильно. В приведённой к классу Config документации всё довольно просто:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//необязательное поле
var something = optional[Duration]

//обязательное поле
var level = required[Int]

//вычисляемое (lazily evaluated!) поле
var nextLevel = computed(level + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2&gt;Конфигурация компонентов&lt;/h2&gt;

&lt;p&gt;В вышеприведённом примере мы вынесли настройку базы данных в отдельный класс DBConfig. Иногда, со стороны приложения бывает удобно вынести конфигурацию в отдельный класс, но усложнять структуру конфиг-файла не хочется. Хорошим примером является случай, когда конфигурируемый компонент находится в другом (под)проекте. В этом случае, конфиг можно объявить трейтом и подмешать его в основной конфиг&lt;/p&gt;

&lt;p&gt;Представим, что мы хотим добавить в наш север небольшой внутренний почтовый сервис для отсылки писем пользователям.&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait MailConfig {
  def smtpServer:  String
  def smtpPort:    String
  def fromAddress: String  
}

class MailManager(val config: MailConfig) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Теперь мы просто подмешиваем трейт в наш основной конфиг, перегружая его методы нашими &lt;code&gt;var&lt;/code&gt;ами:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyServerConfig 
extends ServerConfig[MyServer] 
with MailConfig
{
  ...

  var smtpServer = required[String]
  var smtpPort = 24
  var fromAddress = &quot;noreply@domain.com&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;В нашем конфиг-файле (&lt;code&gt;test.scala&lt;/code&gt;) эти поля будут работать точно так же как и все остальные. При инстанциировании менеджера можно просто передать ему общий конфиг:&lt;/p&gt;

&lt;p&gt;``` scala&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MyServer(val config: MyServerConfig) 
{
  val db = new DB(config.dbConfig)
  val mailer = new MailManager(config)

  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;Также, в отдельный трейт можно вынести готовые значения для настроек если они представляют собой что-то более сложное чем простые значения.&lt;/p&gt;

&lt;p&gt;Вот собственно и всё что я хотел рассказать об использовании ostrich для конфигурирования. Я намеренно не стал рассматривать имеющиеся в ServerConfig поля для настройки логгинга, статистики и админки. Мы вернёмся к ним попозже, когда я буду рассказывать о соответствующих фичах &quot;страуса&quot;.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Scala IRL. Часть 1: конфиги.</title>
    <link href="http://digal.github.com/blog/2011/08/23/scala-irl-1-configs/"/>
    <updated>2011-08-23T22:40:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/23/scala-irl-1-configs</id>
    <content type="html">&lt;p&gt;Для Scala, как для языка довольно молодого, пока ещё нет (а может уже и не будет) единого стандарта для такой обыденной вещи как конфиг-файлы. Вариантов не так уж много и в этом посте я хочу сделать небольшой обзор тех, которые мне так или иначе довелось использовать.&lt;/p&gt;

&lt;h3&gt;.properties&lt;/h3&gt;

&lt;p&gt;Текстовые и XML файлы, хранящие пары &quot;ключ-значение&quot;. Вполне подходят для конфигурирования большинства проектов, а в стандартной библиотеке JRE, есть средства для работы с ними. Что касается поддержки со стороны Scala, в пакете &lt;code&gt;scala.collection&lt;/code&gt; есть объекты &lt;code&gt;JavaConverters&lt;/code&gt; и &lt;code&gt;JavaConversions&lt;/code&gt;, предоставляющие implicit методы для конвертации объектов класса &lt;code&gt;Properties&lt;/code&gt; в &lt;code&gt;mutable.Map[String, String]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Эти файлы часто используются не столько для хранения конфигов, сколько для локализации. Тут нельзя промолчать об одной их особенности, о которой, наверное, знает каждый Java-программист, но которая всегда меня изумляла: в платформе, где Unicode является основной кодировкой для работы со строками, для хранения локализованных строк предлагается формат, &lt;strong&gt;не поддерживаюший unicode&lt;/strong&gt;. Файлы предлагается сначала писать в unicode, а потом конвертировать в странный и уродливый формат утилитой native2ascii. Ну не отвратительно ли?&lt;/p&gt;

&lt;p&gt;Эти же файлы использует фреймворк Lift (с расширением .props), добавляя к ним &lt;a href=&quot;http://www.assembla.com/wiki/show/liftweb/Run_Modes&quot;&gt;замысловатый механизм&lt;/a&gt; выбора нужного файла в зависимости от режима работы (run mode) и окружения.&lt;/p&gt;

&lt;h3&gt;XML и JSON&lt;/h3&gt;

&lt;p&gt;Здесь всё понятно: стандартных библиотек целая куча, и старые явовские, и специально сделанные для Scala с вкусностями типа XPath-подобных DSL. Такие конфиги имеют привычку разрастаться до неприличных размеров, а JSON ещё и не умеет удобно работать с длинными и многострочными значениями и не имеет констукции для комментариев. Впрочем, можно просто использовать для этой цели обычные поля, которые при чтении конфига будут игнорироваться.&lt;/p&gt;

&lt;h3&gt;configgy&lt;/h3&gt;

&lt;p&gt;configgy - замечательная Scala-библиотека, выполняющая сразу две задачи: работа с конфиг-файлами и удобный логгинг. Эти задачи практически никак не связаны между собой (за исключением того, что логгинг тоже надо конфигурировать), но это именно те две задачи, которые требуется решать в практически любом проекте больше сотни строк.&lt;/p&gt;

&lt;p&gt;Configgy поддерживает несколько форматов для конфигов, как линейный, так и со вложенными блоками, типа такого:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# JDBC parameters
jdbc {
    driver = &quot;com.mysql.jdbc.Driver&quot;
    uri = &quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF8&quot;
    limit = 5000 # Batch size for selects
}

#logging parameters, see configgy readme for details
log {
    filename = &quot;debug.log&quot;
    level = &quot;debug&quot;
    utc = false
    console = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Логгинг автоматически подхватывает параметры из секции log при чтении конфига, что очень удобно - вся обычная рутина с конфигурированием сводится практически к одной строчке.&lt;/p&gt;

&lt;h3&gt;Ostrich&lt;/h3&gt;

&lt;p&gt;Когда мы собрались прицепить configgy к одному из очередных наших проектов, то обнаружили (на &lt;a href=&quot;https://github.com/robey/configgy&quot;&gt;страничке&lt;/a&gt; проекта на github), что проект теперь deprecated (хотя и будет пока поддерживаться в каком-то виде) и вместо него предлагается использовать Scala-библиотеки от twitter. Для логгинга - util-logging из набора &lt;a href=&quot;https://github.com/twitter/util&quot;&gt;Util&lt;/a&gt;, который помимо лог-файлов поддерживает &lt;a href=&quot;https://github.com/facebook/scribe&quot;&gt;Scribe&lt;/a&gt; и Syslog, для конфигурирования - &lt;a href=&quot;https://github.com/twitter/ostrich&quot;&gt;ostrich&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ostrich - это довольно развесистая библиотека, предназначенная для&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;конфигурирования&lt;/li&gt;
&lt;li&gt;сбора статистики&lt;/li&gt;
&lt;li&gt;запуска/остановки приложения и его сервисов&lt;/li&gt;
&lt;li&gt;предоставления админского интерфейса через HTTP или просто сокет&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Главная особенность конфиг-файлов ostrich - они являются обычными Scala-классами, со всемы вытекающими: они типизированы и могут наследоваться от абстрактного класса или трейта. В тех местах, где конфигурация используется, отпадает необходимость извлечения значений из конфига, проверки на то что они присутствуют, предоставления дефолтных значений и приведения к нужному типу. Обратной стороной медали можно было бы назвать необходимость компиляции конфига в рантайме, но поскольку делать это нужно не так уж часто (обычно при старте приложения), то ради красивых type-safe конфигов можно и потерпеть.&lt;/p&gt;

&lt;p&gt;Также, ostrich предоставляет готовую заготовку ServerConfig, включающую в себя настройку логгинга и поднятие http/socket интерфейса при загрузке.&lt;/p&gt;

&lt;p&gt;Несмотря на фичастость, мне кажется что автор configgy совершенно зря остановил развитие библиотеки: она очень проста в использовании и идеально подходит для большого диапазона проектов. Ostrich же относится к совершенно другой категории и для многих задач его навороченность выглядит излишней. Кроме того, в его использовании есть несколько подводных камней, о которых я постараюсь рассказать поподробнее в следующий раз.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Очередная классификация программистов</title>
    <link href="http://digal.github.com/blog/2011/08/20/types-of-programmers/"/>
    <updated>2011-08-20T11:31:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/20/types-of-programmers</id>
    <content type="html">&lt;p&gt;Утром наткнулся в zite на замечательную статью: &quot;&lt;a href=&quot;http://techiferous.com/2011/08/are-you-a-good-programmer/&quot;&gt;Are You a Good Programmer?&lt;/a&gt;&quot;, в которой приведена интересная классификация &lt;em&gt;хороших&lt;/em&gt; программистов. Несмотря на всю относительность таких классификаций, очень занимательно примерять это всё на себя.&lt;/p&gt;

&lt;p&gt;Мне трудно судить, являюсь ли я на данный момент действительно хорошим программистом (и каким критериям, собственно, надо для этого соответствовать?), но определённо могу сказать что последний год развиваюсь в сторону первого типа (Philosopher). Этому явно способствует и спользование такого языка как scala, склоняющая к очень &quot;безопасному&quot; стилю программирования, и позволяющая хорошо управлять ограничениями в коде с помощью системы типов, при этом сохраняя красоту и лаконичность кода.&lt;/p&gt;

&lt;p&gt;Было бы интересно узнать, к какому типу вы себя относите? Понятно что типы могут сочетаться в разных пропорциях, и вполне возможно, что можно придумать ещё несколько.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Ура! Новый хоумпейж!</title>
    <link href="http://digal.github.com/blog/2011/08/15/"/>
    <updated>2011-08-15T11:19:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/</id>
    <content type="html">&lt;p&gt;Уф, я кажется таки настроил &lt;a href=&quot;http://octopress.org/&quot; title=&quot;Octopress: A blogging framework for hackers.&quot;&gt;octopress&lt;/a&gt; и наверное таки останусь здесь.
Несмотря на излишнюю красноглазость (девиз октопресса говорит сам за себя) эта платформа ближе всего к идеалу блогдвижка, как я его представляю.
Как дойдут руки, я попробую доконфигурить это до юзабельного состояния (&quot;ха-ха!&quot; - как бы говорит линуксоедный опыт) и начать уже писать посты,
благо исчезает последняя отмазка этого не делать - отсутствие нормального блога.&lt;/p&gt;

&lt;!--more--&gt;


&lt;p&gt;До этого я пробовал ЖЖ, blogspot, tumblr, posterous и бложеки на корпоративном сайте. Прижился только &lt;a href=&quot;http://twitter.com/digal&quot;&gt;твитор&lt;/a&gt;,
но его 140 символов не всегда хватает чтобы выпендриться умом.&lt;/p&gt;

&lt;p&gt;Я пока не уверен в идеальном процентном соотношении красноглазия/лытдыбра (в смысле постов на профессиональные/личные темы), так что буду писать
как получится, а дальше отрегулирую по фидбекам.&lt;/p&gt;

&lt;p&gt;Алсо, если кто-то будет тоже настраивать octopress, то не наступайте на граблю, на которую я убил наверное час нервных рефрешей этой страницы:
если делать всё по официальному гайду, то скорее всего дефолтным бранчем в гитхаб-репозитории у вас окажется &quot;source&quot;, а не &quot;master&quot;, который
собственно и нужно публиковать. Переключить это можно в настройках репозитория.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Hello?</title>
    <link href="http://digal.github.com/blog/2011/08/15/hello/"/>
    <updated>2011-08-15T11:15:00+04:00</updated>
    <id>http://digal.github.com/blog/2011/08/15/hello</id>
    <content type="html">&lt;p&gt;Привет? Рас-рас!&lt;/p&gt;
</content>
  </entry>
  
</feed>
